# **Chapter02. InnoDB的介绍**

```mysql
-- 1. 查看InnoDB的具体运行状态信息
    show engine innodb status;
   
-- 2. 查看设置的LRU列表页中可用的数量
	show variables like 'innodb_lru_scan_depth'\G

-- 3. 查看强制checkpoint的脏页比例
	show variables like 'innodb_max_dirty_pages_pct'\G

-- 4 checkpoint执行的四种情况
Sharp CheckPoint
数据库发生关闭时，强制将所有脏页刷新到磁盘
Fuzzy CheckPoint
(1) Master Thread 定时按比例刷新脏页
(2) Flush_LRU_list 为了保证LRU列表有足够的空闲页可以使用，移除尾端数据时刷新脏页
(3) Async/Sync Flush
(4) Dirty_Page_Too_Much 脏页过多

-- 5. 设置回收undo页的数量
show variables like '%innodb_purge_batch_size%'\G
```



## 2.1 1.0版本之前的Master Thread伪代码

```mysql
组成：（loop、flush loop、suspend loop、backgroud loop）

void master_thread() {
	goto loop;
// --------------每1s的操作-------
loop:
for(int i=0; i<10; i++) {
	Thread.Sleep(1);// 睡1s
	// 1. 日志缓冲刷新到磁盘
	if (last_one_second_times < 5) {
		// 2. 合并插入缓冲
	}
	if (buf_get_modified_ratio_pct > innodb_max_dirty_pages_pct) {
		// 3. 刷新脏页
	}
	if (no user activity) {
		go back backgroud loop;
	}
}
// --------------每10s的操作-------
if (last_ten_second_ios < 200) { // 这是任务磁盘足够的IO能力
	do buffer pool flush 100 dirty page
}
// 1. 合并插入缓冲
// 2. 日志缓冲刷新到磁盘
// 3. 删除无用的Undo页，每次最多回收20个
// 4. 刷新100个或者10个脏页到磁盘，这里会根据脏页的比例计算
if (buf_get_nodified_ratio_pct > 70) {
	回收100页
} else {
	回收10页
}

do sth. per ten second
// --------------后台操作-------
backgroud loop:
	// 1. 删除无用Undo页
	// 2. 合并插入缓冲20个
	if not idle
		goto loop;
	else
		goto flush loop;
Flush loop:
	// 	刷新100个脏页
	if (buf_get_modified_ratio_pct > innodb_max_dirty_pages_pct)
		goto flush loop;
	else
		goto Suspend loop;
Suspend loop:
	// Master Thread 挂起
}
```



## 2.2 1.2版本之前的Master Thread伪代码

```mysql

```



## 2.3 1.2版本的Master Thread伪代码

```mysql

```



# Chapter03 文件



# Chapter05 索引和算法